# GPT_PROJECT_GUIDELINES.md

## 🎯 프로젝트 목표
김포/인천 ↔ 제주 항공권을 네이버 항공권 검색 결과 기반으로 모니터링하고,
매진 상태 → 재오픈된 항공권이 감지되면 실시간으로 사용자에게 알림을 보내는 웹앱 구축

- ❌ 자동 예매 없음
- ✔️ 실시간 알림 전용 시스템

---

## 🧩 핵심 기능별 구성요소 및 역할

| 구성 요소               | 역할                                                  |
|------------------------|--------------------------------------------------------|
| GitHub 연동 (1단계)     | 프로젝트 버전 관리, 배포용 연동                         |
| 웹 UI (Streamlit)       | 사용자 조건 입력 (출/도착지, 날짜, 시간대, 이메일)         |
| 입력 처리 모듈          | 입력값 구조화 및 유효성 검사 (user_config)              |
| 항공편 확인 모듈        | 네이버 항공권에서 항공편 정보 조회                      |
| 필터링 모듈             | 시간대/조건 기반 필터링                                |
| 알림 모듈               | 이메일 → (추후) SMS 전송                              |
| 감시 루프               | 주기적 실행, 중복 알림 방지                            |
| 배포 플랫폼             | Streamlit Cloud 또는 Render로 외부 접근 가능하게 설정     |

---

## 📋 전체 개발 단계 및 순서

| 단계 | 설명 |
|------|------|
| 1단계: GitHub 연동 | 레포 생성, 초기 파일 커밋 (README.md, .gitignore, requirements.txt), 이후 전 개발 Git 기반 관리 |
| 2단계: UI 설계 (Streamlit) | 날짜/시간대/공항/이메일 입력 UI + 등록 버튼 구현 → 이 단계에서 디자인 고정 |
| 3단계: 입력값 구조화 (user_config) | 입력값을 dict 형태로 정리, 누락/이상치 처리 포함 |
| 4단계: 항공편 확인 모듈 (check_ticket()) | 네이버 XHR 구조 분석 → 조건에 맞는 항공편 추출 |
| 5단계: 알림 모듈 (send_email_alert()) | Gmail SMTP 기반 이메일 발송 구현, 템플릿 구성 |
| 6단계: 감시 루프 구성 | schedule, threading 또는 async로 주기 실행, 중복 알림 방지 로직 포함 |
| 7단계: 웹앱 배포 | GitHub → Streamlit Cloud 배포, 실사용자 테스트 가능 상태까지 |

---

## 🔄 확장 고려 사항 (단계와 무관하게 추가 가능)

| 확장 기능             | 설명 |
|----------------------|------|
| SMS 알림 전환          | Solapi, 알리고 등 SMS API 연동 (email 모듈 구조 재사용) |
| 사용자 조건 저장       | SQLite 또는 JSON 기반 간단한 유저 설정 저장소 도입 |
| UI 감성 업그레이드     | Streamlit Theme 적용 or Bootstrap 스타일 흉내 |
| 알림 로그 기록         | 어떤 항공편이 언제 누구에게 알림 전송됐는지 기록 |
| 다중 날짜 감시         | 하루가 아닌 특정 기간 동안 항공권 재오픈 모니터링 |

---

## 📌 설계 철학 및 장점 요약

- **모듈화 설계**: 각 단계가 독립 → 유지보수 및 확장에 강함
- **Streamlit UI 선 고정**: 이후 구조 안정성 확보
- **필터링 & 비교 중심의 알림**: 중복 방지 / 실사용 효율성 높음
- **실제 사용자 니즈에 집중**: ‘취소표 감지’ 기반의 실질적 MVP
- **배포 및 운영까지 고려된 현실적인 구조

---

## 🗂 ChatGPT 협업을 위한 대화창 제목 규칙

이 문서는 ChatGPT가 매 대화창마다 참조할 기준 파일이며, **모든 대화는 다음의 제목 규칙을 따릅니다.**  
이를 통해 ChatGPT는 각 대화의 맥락을 식별하고, 이전 대화의 흐름을 정확히 이어받을 수 있습니다.

### ✅ 제목 작성 규칙
- 형식: `[단계-순서. 제목]`
  - 예시:
    - `0-1. 항공권 알림 프로그램 구조 논의` → *0단계 = 구조 기획 및 설계*
    - `1-1. GitHub 연동` → *1단계 = 실질적 개발 시작*
    - `2-3. UI 입력 검증 추가`

- `단계 번호`는 전체 프로젝트 단계 (`📋 전체 개발 단계 및 순서`)를 따릅니다.
- `순서 번호`는 해당 단계 내에서 대화가 진행된 순서를 의미합니다.

### 🤖 ChatGPT의 역할
- ChatGPT는 **각 대화창의 제목을 사용해 현재 단계와 주제를 인식**합니다.
- 따라서 이 문서의 존재와 제목 규칙을 기반으로 **앞선 대화의 맥락을 자연스럽게 이어갈 수 있습니다.**
- 사용자 역시 새로운 대화창을 만들 때 이 규칙을 따르기로 약속했습니다.

---

이 구조 덕분에 ChatGPT는 각각의 개발 단계에 대한 흐름을 기억하고, **파일 없이도 맥락 기반의 지원을 이어갈 수 있습니다.**


---

## 🧠 GitHub 사용 관련 상시 지원 안내

이 프로젝트는 GitHub 기반으로 진행되며, 전체 단계에 걸쳐 Git 기능(브랜치, 커밋, 푸시 등)을 지속적으로 활용합니다.  
하지만 사용자가 GitHub에 익숙하지 않을 수 있기에, ChatGPT는 다음과 같은 방식으로 **Git 연동을 도와줍니다.**

### 🤖 ChatGPT의 역할

- 각 단계에서 Git 관련 작업(브랜치 생성, 커밋, 푸시 등)이 필요할 경우,  
  → **단순히 코드만 주지 않고,** *“어떻게 연동할지”*까지 함께 설명합니다.
- 사용자가 Git에 점차 익숙해지면  
  → **필요한 부분만 간결하게 상기**하며, 반복 설명을 줄여나갑니다.

### 🧩 예시

| 상황 | ChatGPT의 대응 |
|------|----------------|
| `2단계 UI 작업 중` | `"지금 작업은 dev 브랜치에서 하시는 게 좋겠어요!"`<br>`"이 커밋 메시지는 feat: UI 입력폼 구현 이 어울려요!"` |
| 사용자가 익숙해진 이후 | `"git push 잊지 마세요 👍"` 정도로 짧게 상기 |

### 📌 기본 Git 규칙 요약

- **브랜치 전략**
  - `main`: 배포용
  - `dev`: 개발 작업용
  - `feature/xxx`: 기능 단위 작업
- **커밋 메시지 예시**
  - `feat: 이메일 알림 기능 추가`
  - `fix: UI 버그 수정`

> 💬 *“내가 Git에 익숙하지 않다고 느껴진다면, 편하게 물어보세요!  
> 너무 빨리 넘어가지 않고, 같이 천천히 정리해 드릴게요.”*

---

## 📌 단계별 메모 작성 안내

각 개발 단계가 끝날 때, 다음 두 가지 유형의 메모를 자유롭게 남길 수 있습니다:

1. ✅ **정리 요약**

   - 해당 단계에서 수행한 작업의 요점, 디렉토리 구조 변화, 커밋 흐름 등을 요약합니다.
   - 이후 단계와의 연결성을 파악하거나, 리뷰 시 참고용입니다.

2. 🧠 **기억 보존 & 기준 유지 메모**

   - 다음 단계에서 GPT가 반드시 기억하고 따라야 할 약속 또는 구조적 기준을 메모합니다.
   - 예: 인풋/아웃풋 관계, 파일 간 의존성, 명명 규칙, 향후 확장을 고려한 전제 조건 등
   - 마치 코드 주석처럼, “향후 혼란 방지”와 “기억 유지를 위한 단서” 역할을 합니다.

GPT는 이 메모를 자동으로 인식하고, 이후 모든 단계 대화에서 일관되게 반영해야 합니다.

---

## 1단계 메모

### ✅ 정리 요약

- 로컬 Git 초기화 완료  
  위치: `C:/Users/USER/flight-ticket-alert/`  
  (Git Bash 기준: `~/flight-ticket-alert/`)
- GitHub 레포지토리 연결 및 `main`, `dev` 브랜치 구성 완료
- 초기 파일 생성:
  - `README.md`, `.gitignore`, `requirements.txt`
  - `app.py`, `check_ticket.py`, `user_config.py`, `send_alert.py`, `monitor.py`
- 커밋 메시지 전략 도입: `"feat:"`, `"chore:"` 등 prefix 사용
- `dev` 브랜치 기준으로 개발 시작
- `.md` 문서도 GitHub에 등록하여 Markdown 뷰 활용 중

### 🧠 기억 보존 & 기준 유지 메모 (GPT 필수 인식 항목)

- 📍 **작업 위치는 항상**:  
  `C:/Users/USER/flight-ticket-alert/`  
  또는 `~/flight-ticket-alert/`
- 📁 파일 구조 및 작업 기준은 해당 디렉토리 하위로만 구성
- 브랜치 전략:
  - `main`: 배포용 (항상 안정 상태 유지)
  - `dev`: 실시간 개발용 (기본 작업 공간)
  - 필요 시 `feature/*` 브랜치에서 세부 기능 개발 후 `dev`로 merge
- 커밋 메시지 규칙 (접두어):
  - `feat:` 기능 추가
  - `fix:` 버그 수정
  - `chore:` 설정, 초기화, 구조 정리
  - `docs:` 문서 작성 및 수정
- GPT는 이 기준을 반드시 기억하고, 이후 대화에서 흐트러지지 않도록 유지해야 함